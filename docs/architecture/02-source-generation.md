# Source Generation Architecture

## Overview

The source generator analyzes types decorated with `[CsvRecord]` and generates high-performance serialization code at compile time, eliminating runtime reflection and enabling aggressive optimization.

## Generator Pipeline

```
Source Code with [CsvRecord]
         ↓
   Roslyn Analyzer
         ↓
   Extract Metadata
         ↓
   Validate Configuration
         ↓
   Generate Serialization Code
         ↓
   Emit to Compilation
```

## Generated Code Structure

For each `[CsvRecord]` class, the generator produces:

1. **ICsvRecordInfo<T> implementation** - Metadata interface
2. **Reader implementation** - Deserialization logic
3. **Writer implementation** - Serialization logic
4. **Converter registration** - Auto-registration with CsvReader/Writer

## Example: Input Class

```csharp
using CsvHandler;

namespace MyApp.Models;

[CsvRecord]
public partial class Person
{
    [CsvField(Index = 0)]
    public int Id { get; set; }

    [CsvField(Name = "full_name")]
    public string Name { get; set; } = "";

    [CsvField(Index = 2, Format = "yyyy-MM-dd")]
    public DateTime BirthDate { get; set; }

    [CsvField(Optional = true)]
    public string? Email { get; set; }

    [CsvIgnore]
    public int CalculatedAge =>
        DateTime.Now.Year - BirthDate.Year;
}
```

## Generated Output

### Part 1: Metadata Interface Implementation

```csharp
// <auto-generated/>
#nullable enable

namespace MyApp.Models;

partial class Person : CsvHandler.ICsvRecord<Person>
{
    private static class PersonCsvMetadata
    {
        public static ReadOnlySpan<byte> IdName => "Id"u8;
        public static ReadOnlySpan<byte> NameName => "full_name"u8;
        public static ReadOnlySpan<byte> BirthDateName => "BirthDate"u8;
        public static ReadOnlySpan<byte> EmailName => "Email"u8;

        public const int FieldCount = 4;

        public static readonly CsvHandler.CsvFieldInfo[] Fields = new[]
        {
            new CsvHandler.CsvFieldInfo(
                Name: "Id",
                Index: 0,
                Type: typeof(int),
                IsOptional: false,
                Format: null),
            new CsvHandler.CsvFieldInfo(
                Name: "full_name",
                Index: 1,
                Type: typeof(string),
                IsOptional: false,
                Format: null),
            new CsvHandler.CsvFieldInfo(
                Name: "BirthDate",
                Index: 2,
                Type: typeof(DateTime),
                IsOptional: false,
                Format: "yyyy-MM-dd"),
            new CsvHandler.CsvFieldInfo(
                Name: "Email",
                Index: 3,
                Type: typeof(string),
                IsOptional: true,
                Format: null)
        };
    }

    static CsvHandler.ICsvRecordInfo<Person>
        CsvHandler.ICsvRecord<Person>.Metadata =>
            PersonCsvRecordInfo.Instance;
}
```

### Part 2: Reader Implementation

```csharp
// <auto-generated/>
namespace MyApp.Models;

internal sealed class PersonCsvReader :
    CsvHandler.ICsvRecordReader<Person>
{
    public static readonly PersonCsvReader Instance = new();

    private PersonCsvReader() { }

    public Person Read(
        CsvHandler.CsvFieldReader fieldReader,
        CsvHandler.CsvReaderOptions options)
    {
        var record = new Person();

        // Field 0: Id (required, int)
        if (!fieldReader.TryReadInt32(out var field0))
        {
            throw new CsvHandler.CsvFormatException(
                fieldReader.RecordNumber,
                0,
                "Id",
                "Failed to parse Int32");
        }
        record.Id = field0;

        // Field 1: Name (required, string, custom name)
        if (!fieldReader.TryReadString(out var field1))
        {
            throw new CsvHandler.CsvFormatException(
                fieldReader.RecordNumber,
                1,
                "full_name",
                "Failed to read string");
        }
        record.Name = field1;

        // Field 2: BirthDate (required, DateTime, custom format)
        if (!fieldReader.TryReadDateTime(
            "yyyy-MM-dd"u8,
            out var field2))
        {
            throw new CsvHandler.CsvFormatException(
                fieldReader.RecordNumber,
                2,
                "BirthDate",
                "Failed to parse DateTime with format 'yyyy-MM-dd'");
        }
        record.BirthDate = field2;

        // Field 3: Email (optional, string)
        if (fieldReader.TryReadString(out var field3))
        {
            record.Email = field3;
        }

        return record;
    }

    public bool TryRead(
        CsvHandler.CsvFieldReader fieldReader,
        CsvHandler.CsvReaderOptions options,
        out Person? record,
        out CsvHandler.CsvError? error)
    {
        record = new Person();
        error = null;

        // Field 0: Id
        if (!fieldReader.TryReadInt32(out var field0))
        {
            error = new CsvHandler.CsvError(
                fieldReader.RecordNumber,
                0,
                "Id",
                "Failed to parse Int32");
            record = null;
            return false;
        }
        record.Id = field0;

        // Field 1: Name
        if (!fieldReader.TryReadString(out var field1))
        {
            error = new CsvHandler.CsvError(
                fieldReader.RecordNumber,
                1,
                "full_name",
                "Failed to read string");
            record = null;
            return false;
        }
        record.Name = field1;

        // Field 2: BirthDate
        if (!fieldReader.TryReadDateTime(
            "yyyy-MM-dd"u8,
            out var field2))
        {
            error = new CsvHandler.CsvError(
                fieldReader.RecordNumber,
                2,
                "BirthDate",
                "Failed to parse DateTime");
            record = null;
            return false;
        }
        record.BirthDate = field2;

        // Field 3: Email (optional)
        if (fieldReader.TryReadString(out var field3))
        {
            record.Email = field3;
        }

        return true;
    }

    public IReadOnlyList<string> GetHeaders()
    {
        return new[]
        {
            "Id",
            "full_name",
            "BirthDate",
            "Email"
        };
    }
}
```

### Part 3: Writer Implementation

```csharp
// <auto-generated/>
namespace MyApp.Models;

internal sealed class PersonCsvWriter :
    CsvHandler.ICsvRecordWriter<Person>
{
    public static readonly PersonCsvWriter Instance = new();

    private PersonCsvWriter() { }

    public void Write(
        Person record,
        CsvHandler.CsvFieldWriter fieldWriter,
        CsvHandler.CsvWriterOptions options)
    {
        // Field 0: Id
        fieldWriter.WriteInt32(record.Id);

        // Field 1: Name
        fieldWriter.WriteString(record.Name);

        // Field 2: BirthDate (custom format)
        fieldWriter.WriteDateTime(
            record.BirthDate,
            "yyyy-MM-dd"u8);

        // Field 3: Email (optional)
        if (record.Email is not null)
        {
            fieldWriter.WriteString(record.Email);
        }
        else
        {
            fieldWriter.WriteEmpty();
        }

        fieldWriter.EndRecord();
    }

    public ValueTask WriteAsync(
        Person record,
        CsvHandler.CsvFieldWriter fieldWriter,
        CsvHandler.CsvWriterOptions options,
        CancellationToken cancellationToken = default)
    {
        Write(record, fieldWriter, options);
        return ValueTask.CompletedTask;
    }

    public IReadOnlyList<string> GetHeaders()
    {
        return new[]
        {
            "Id",
            "full_name",
            "BirthDate",
            "Email"
        };
    }
}
```

### Part 4: Registration

```csharp
// <auto-generated/>
namespace MyApp.Models;

partial class Person
{
    static Person()
    {
        // Auto-register with CsvReader/Writer
        CsvHandler.CsvRecordRegistry.Register<Person>(
            PersonCsvReader.Instance,
            PersonCsvWriter.Instance);
    }
}
```

## Generator Implementation

### CsvRecordGenerator Class

```csharp
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CsvHandler.SourceGeneration;

[Generator]
public class CsvRecordGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register for syntax notifications
        var recordDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: IsCsvRecordCandidate,
                transform: GetSemanticModel)
            .Where(m => m is not null);

        // Generate code
        context.RegisterSourceOutput(
            recordDeclarations,
            (spc, record) => GenerateSource(spc, record!));
    }

    private static bool IsCsvRecordCandidate(
        SyntaxNode node,
        CancellationToken ct)
    {
        // Quick syntactic check
        return node is ClassDeclarationSyntax
        {
            AttributeLists.Count: > 0,
            Modifiers: var modifiers
        } && modifiers.Any(m => m.Text == "partial");
    }

    private static RecordInfo? GetSemanticModel(
        GeneratorSyntaxContext context,
        CancellationToken ct)
    {
        var classDeclaration =
            (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel
            .GetDeclaredSymbol(classDeclaration, ct);

        if (symbol is null)
            return null;

        // Check for [CsvRecord] attribute
        var csvRecordAttr = symbol.GetAttributes()
            .FirstOrDefault(a =>
                a.AttributeClass?.Name == "CsvRecordAttribute");

        if (csvRecordAttr is null)
            return null;

        // Extract field information
        var fields = new List<FieldInfo>();
        foreach (var member in symbol.GetMembers())
        {
            if (member is not IPropertySymbol property)
                continue;

            var ignoreAttr = property.GetAttributes()
                .FirstOrDefault(a =>
                    a.AttributeClass?.Name == "CsvIgnoreAttribute");

            if (ignoreAttr is not null)
                continue;

            var fieldAttr = property.GetAttributes()
                .FirstOrDefault(a =>
                    a.AttributeClass?.Name == "CsvFieldAttribute");

            fields.Add(ExtractFieldInfo(property, fieldAttr));
        }

        return new RecordInfo(
            Symbol: symbol,
            Fields: fields);
    }

    private static void GenerateSource(
        SourceProductionContext context,
        RecordInfo recordInfo)
    {
        var builder = new SourceBuilder();

        // Generate metadata
        builder.AppendMetadata(recordInfo);

        // Generate reader
        builder.AppendReader(recordInfo);

        // Generate writer
        builder.AppendWriter(recordInfo);

        // Generate registration
        builder.AppendRegistration(recordInfo);

        var source = builder.ToString();
        var fileName = $"{recordInfo.Symbol.Name}.g.cs";

        context.AddSource(fileName, source);
    }
}
```

## Optimization Strategies

### 1. Span-Based Parsing

Generated code uses `ReadOnlySpan<byte>` for zero-allocation parsing:

```csharp
// Generated code uses spans
public bool TryReadInt32(ReadOnlySpan<byte> utf8Data, out int value)
{
    return Utf8Parser.TryParse(utf8Data, out value, out _);
}
```

### 2. Stackalloc for Small Buffers

For formatting, use stackalloc when size is known:

```csharp
// Generated writer code
Span<byte> buffer = stackalloc byte[32]; // Enough for most numbers
if (Utf8Formatter.TryFormat(record.Id, buffer, out int written))
{
    fieldWriter.WriteRaw(buffer.Slice(0, written));
}
```

### 3. Static UTF-8 Literals

Use `"text"u8` for compile-time UTF-8 conversion:

```csharp
// Generated code
private static ReadOnlySpan<byte> FieldName => "full_name"u8;
```

### 4. Devirtualization

Generated code is non-virtual and can be inlined:

```csharp
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public void Write(Person record, CsvFieldWriter writer, ...)
{
    // Direct property access, no virtual calls
    writer.WriteInt32(record.Id);
}
```

### 5. Branch Elimination

For optional fields, use pattern matching to eliminate branches:

```csharp
// Generated code for optional field
switch (record.Email)
{
    case not null:
        fieldWriter.WriteString(record.Email);
        break;
    default:
        fieldWriter.WriteEmpty();
        break;
}
```

## Diagnostics

The generator provides helpful diagnostics:

| Code | Severity | Message |
|------|----------|---------|
| CSV001 | Error | Class must be partial |
| CSV002 | Error | Field index already used |
| CSV003 | Warning | Property is write-only |
| CSV004 | Error | Unsupported type |
| CSV005 | Warning | Custom converter not found |
| CSV006 | Error | Duplicate field names |
| CSV007 | Warning | Format string invalid for type |

Example diagnostic:

```csharp
[CsvRecord]
public class Person // CSV001: Class must be partial
{
    [CsvField(Index = 0)]
    public int Id { get; set; }
}
```

## Testing Generated Code

Use snapshot testing with Verify:

```csharp
[Fact]
public Task GeneratesCorrectCode()
{
    var source = """
        using CsvHandler;

        [CsvRecord]
        public partial class Person
        {
            [CsvField(Index = 0)]
            public int Id { get; set; }
        }
        """;

    var result = CSharpGeneratorDriver
        .Create(new CsvRecordGenerator())
        .RunGeneratorsAndUpdateCompilation(
            compilation,
            out var output,
            out var diagnostics);

    return Verify(result);
}
```

## Fallback Strategy

When source generation is not available (dynamic types, runtime scenarios), fall back to reflection-based implementation:

```csharp
// CsvReader automatically detects
public static CsvReader<T> Create<T>(string path)
{
    // Check if T has generated code
    if (CsvRecordRegistry.HasGeneratedCode<T>())
    {
        return new CsvReader<T>(
            path,
            CsvRecordRegistry.GetReader<T>());
    }

    // Fall back to reflection
    return new CsvReader<T>(
        path,
        new ReflectionCsvReader<T>());
}
```

The reflection fallback uses expression trees for better performance than pure reflection:

```csharp
class ReflectionCsvReader<T> : ICsvRecordReader<T>
{
    private readonly Func<CsvFieldReader, T> _readFunc;

    public ReflectionCsvReader()
    {
        _readFunc = BuildReader();
    }

    private Func<CsvFieldReader, T> BuildReader()
    {
        // Build expression tree for reading
        var param = Expression.Parameter(typeof(CsvFieldReader));
        var variable = Expression.Variable(typeof(T));

        // ... build expression tree ...

        return Expression.Lambda<Func<CsvFieldReader, T>>(
            body, param).Compile();
    }
}
```
