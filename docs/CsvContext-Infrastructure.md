# CsvContext Infrastructure for Native AOT Support

## Overview

The CsvContext infrastructure provides a compile-time, reflection-free approach to CSV serialization that is fully compatible with Native AOT and trimming. It achieves this through source generation and strongly-typed delegates.

## Architecture

### Core Components

1. **CsvContext** - Abstract base class for contexts
   - Provides type metadata lookup via `GetTypeInfo<T>()`
   - Can be subclassed manually or via source generation
   - Supports singleton pattern through `Default` property

2. **CsvTypeInfo<T>** - Type-specific metadata and delegates
   - Contains field metadata collection
   - Provides reader/writer delegates for synchronous operations
   - Provides async delegates for streaming scenarios
   - All delegates are strongly-typed (no boxing/reflection)

3. **CsvFieldInfo** - Individual field metadata
   - Field name, order, type information
   - Format specifications and converters
   - Required/optional validation
   - Per-field reader/writer delegates

4. **ICsvConverter<T>** - Custom converter interface
   - Supports user-defined type conversions
   - Works with ReadOnlySpan<byte> for zero-allocation parsing
   - Integrates with IBufferWriter<byte> for zero-allocation writing

## Source Generation

### User Declaration

```csharp
[CsvSerializable(typeof(Person))]
[CsvSerializable(typeof(Order))]
public partial class AppCsvContext : CsvContext
{
    // Implementation generated by source generator
}
```

### Generated Code Structure

The source generator emits:

1. **Type Info Properties**
   ```csharp
   private CsvTypeInfo<Person>? _personTypeInfo;
   private CsvTypeInfo<Person> PersonTypeInfo
   {
       get
       {
           if (_personTypeInfo != null) return _personTypeInfo;
           // Build and cache type info
           return _personTypeInfo = BuildPersonTypeInfo();
       }
   }
   ```

2. **GetTypeInfo Implementations**
   ```csharp
   public override CsvTypeInfo<T>? GetTypeInfo<T>()
   {
       if (typeof(T) == typeof(Person))
           return (CsvTypeInfo<T>)(object)PersonTypeInfo;
       if (typeof(T) == typeof(Order))
           return (CsvTypeInfo<T>)(object)OrderTypeInfo;
       return null;
   }
   ```

3. **Specialized Reader/Writer Delegates**
   ```csharp
   private static Person ReadPerson(ReadOnlySpan<byte> data)
   {
       // Generated field parsing code
   }

   private static void WritePerson(IBufferWriter<byte> writer, Person person)
   {
       // Generated field writing code
   }
   ```

4. **Async Streaming Delegates**
   ```csharp
   private static async IAsyncEnumerable<Person> ReadPersonAsync(Stream stream)
   {
       // Generated async enumeration
   }

   private static async ValueTask WritePersonAsync(Stream stream, Person person)
   {
       // Generated async write
   }
   ```

## Integration with CsvReader/Writer

### CsvReader<T>

```csharp
public static CsvReader<T> Create(Stream stream, CsvContext context)
{
    var typeInfo = context.GetTypeInfo<T>()
        ?? throw new InvalidOperationException($"Type {typeof(T)} not registered");

    return new CsvReader<T>(stream, typeInfo);
}

// Usage
var reader = CsvReader<Person>.Create(stream, AppCsvContext.Default);
await foreach (var person in reader.ReadAsync())
{
    // Process person
}
```

### CsvWriter<T>

```csharp
public static CsvWriter<T> Create(Stream stream, CsvContext context)
{
    var typeInfo = context.GetTypeInfo<T>()
        ?? throw new InvalidOperationException($"Type {typeof(T)} not registered");

    return new CsvWriter<T>(stream, typeInfo);
}

// Usage
var writer = CsvWriter<Person>.Create(stream, AppCsvContext.Default);
await writer.WriteAsync(person);
```

## AOT Compatibility

### What Makes It AOT-Safe

1. **No Reflection**
   - Type metadata is generated at compile-time
   - All type operations use static typing
   - No `Type.GetProperties()` or similar calls

2. **No Dynamic Code Generation**
   - All delegates are known at compile-time
   - Source generator emits concrete implementations
   - No expression trees or IL emission

3. **Trimmable**
   - Only referenced types are included
   - Unused CsvContext types are trimmed away
   - No dynamic type discovery

4. **Static Analysis Friendly**
   - All types registered via attributes
   - Trimmer can see all dependencies
   - RUC/RDC attributes used for reflection paths

### Trim Annotations

```csharp
// DefaultCsvContext (reflection-based) is marked as unsafe
[RequiresUnreferencedCode("Uses reflection, not AOT compatible")]
[RequiresDynamicCode("Uses reflection, not AOT compatible")]
public sealed class DefaultCsvContext : CsvContext
{
    // Reflection-based fallback
}

// Source-generated contexts have no annotations (fully trim-safe)
public partial class AppCsvContext : CsvContext
{
    // Source-generated, fully trim-safe
}
```

## Performance Characteristics

### Memory Efficiency

1. **Zero Allocation Reading**
   - Uses `ReadOnlySpan<byte>` for parsing
   - No intermediate string allocations
   - Direct UTF-8 parsing without encoding conversion

2. **Zero Allocation Writing**
   - Uses `IBufferWriter<byte>` for output
   - Writes directly to buffers
   - No string concatenation or StringBuilder

3. **Lazy Type Info**
   - Type metadata created on first access
   - Cached for subsequent uses
   - Only instantiated types consume memory

### CPU Efficiency

1. **Inlined Code Paths**
   - Reader/writer delegates marked `AggressiveInlining`
   - No virtual dispatch overhead
   - Branch-predictable type switches

2. **Vectorization Opportunities**
   - Span-based APIs enable SIMD
   - Contiguous memory access patterns
   - Modern .NET optimizations apply

## Usage Examples

### Basic Usage

```csharp
// Define types
[CsvRecord]
public class Person
{
    [CsvField(Order = 0)]
    public string Name { get; set; }

    [CsvField(Order = 1)]
    public int Age { get; set; }
}

// Create context
[CsvSerializable(typeof(Person))]
public partial class MyContext : CsvContext { }

// Use context
var context = MyContext.Default;
var reader = CsvReader<Person>.Create(stream, context);
var people = await reader.ReadAllAsync();
```

### Custom Converters

```csharp
public class DateOnlyConverter : ICsvConverter<DateOnly>
{
    public DateOnly Read(ReadOnlySpan<byte> data)
    {
        var str = Encoding.UTF8.GetString(data);
        return DateOnly.ParseExact(str, "yyyy-MM-dd");
    }

    public void Write(IBufferWriter<byte> writer, DateOnly value)
    {
        var str = value.ToString("yyyy-MM-dd");
        writer.Write(Encoding.UTF8.GetBytes(str));
    }
}

[CsvRecord]
public class Event
{
    [CsvField(Order = 0)]
    [CsvConverter(typeof(DateOnlyConverter))]
    public DateOnly EventDate { get; set; }
}
```

### Multiple Contexts

```csharp
// Different contexts for different scenarios
[CsvSerializable(typeof(Person))]
[CsvSerializable(typeof(Address))]
public partial class UserContext : CsvContext { }

[CsvSerializable(typeof(Order))]
[CsvSerializable(typeof(Product))]
public partial class OrderContext : CsvContext { }

// Use appropriate context
var users = CsvReader<Person>.Create(stream, UserContext.Default);
var orders = CsvReader<Order>.Create(stream, OrderContext.Default);
```

## Future Extensions

### Planned Features

1. **Field Metadata Enhancements**
   - Computed fields
   - Conditional serialization
   - Field-level options

2. **Advanced Converters**
   - Multi-field converters
   - Context-aware converters
   - Converter composition

3. **Validation Integration**
   - Required field validation
   - Format validation
   - Cross-field validation

4. **Schema Evolution**
   - Version tolerance
   - Field mapping
   - Backward compatibility

## Implementation Checklist

- [x] CsvContext base class
- [x] CsvTypeInfo<T> metadata class
- [x] CsvFieldInfo field metadata
- [x] ICsvConverter<T> interface
- [x] CsvOptions configuration
- [x] Attribute definitions
- [x] Documentation and examples
- [ ] Source generator implementation
- [ ] Integration with CsvReader<T>
- [ ] Integration with CsvWriter<T>
- [ ] Unit tests
- [ ] Performance benchmarks
- [ ] AOT compatibility tests

## See Also

- [Source Generator Design](./SourceGenerator-Design.md) (TODO)
- [Modern Parsers Integration](./Modern-Parsers.md) (TODO)
- [AOT Testing Guide](./AOT-Testing.md) (TODO)
