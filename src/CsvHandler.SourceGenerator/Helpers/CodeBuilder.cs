using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace CsvHandler.SourceGenerator.Helpers;

/// <summary>
/// Utility class for building source code with proper indentation and formatting.
/// </summary>
internal sealed class CodeBuilder
{
    private readonly StringBuilder _builder;
    private int _indentLevel;
    private bool _isLineStart = true;

    private const string IndentString = "    "; // 4 spaces

    public CodeBuilder(int capacity = 4096)
    {
        _builder = new StringBuilder(capacity);
    }

    /// <summary>
    /// Appends a line of code with current indentation.
    /// </summary>
    public CodeBuilder AppendLine(string line)
    {
        if (_isLineStart && !string.IsNullOrWhiteSpace(line))
        {
            AppendIndent();
        }

        _builder.AppendLine(line);
        _isLineStart = true;
        return this;
    }

    /// <summary>
    /// Appends an empty line.
    /// </summary>
    public CodeBuilder AppendLine()
    {
        _builder.AppendLine();
        _isLineStart = true;
        return this;
    }

    /// <summary>
    /// Appends text without a newline.
    /// </summary>
    public CodeBuilder Append(string text)
    {
        if (_isLineStart && !string.IsNullOrWhiteSpace(text))
        {
            AppendIndent();
        }

        _builder.Append(text);
        _isLineStart = false;
        return this;
    }

    /// <summary>
    /// Increases indentation level.
    /// </summary>
    public CodeBuilder Indent()
    {
        _indentLevel++;
        return this;
    }

    /// <summary>
    /// Decreases indentation level.
    /// </summary>
    public CodeBuilder Unindent()
    {
        if (_indentLevel > 0)
        {
            _indentLevel--;
        }
        return this;
    }

    /// <summary>
    /// Appends an opening brace and increases indentation.
    /// </summary>
    public CodeBuilder OpenBrace()
    {
        AppendLine("{");
        Indent();
        return this;
    }

    /// <summary>
    /// Decreases indentation and appends a closing brace.
    /// </summary>
    public CodeBuilder CloseBrace()
    {
        Unindent();
        AppendLine("}");
        return this;
    }

    /// <summary>
    /// Appends namespace declaration with usings.
    /// </summary>
    public CodeBuilder AppendNamespace(string namespaceName, IEnumerable<string> usings)
    {
        // Auto-generated header
        AppendLine("// <auto-generated/>");
        AppendLine("#nullable enable");
        AppendLine();

        // Using directives
        foreach (var usingDirective in usings.OrderBy(u => u))
        {
            AppendLine($"using {usingDirective};");
        }
        AppendLine();

        // Namespace
        AppendLine($"namespace {namespaceName}");
        OpenBrace();

        return this;
    }

    /// <summary>
    /// Appends a class or record declaration.
    /// </summary>
    public CodeBuilder AppendTypeDeclaration(string typeName, bool isRecord, bool isPartial = true)
    {
        var keyword = isRecord ? "record" : "class";
        var partialKeyword = isPartial ? "partial " : "";

        AppendLine($"public {partialKeyword}{keyword} {typeName}");
        OpenBrace();

        return this;
    }

    /// <summary>
    /// Appends XML documentation comment.
    /// </summary>
    public CodeBuilder AppendXmlDoc(string summary)
    {
        AppendLine("/// <summary>");
        AppendLine($"/// {summary}");
        AppendLine("/// </summary>");
        return this;
    }

    /// <summary>
    /// Appends XML documentation with remarks.
    /// </summary>
    public CodeBuilder AppendXmlDoc(string summary, string remarks)
    {
        AppendLine("/// <summary>");
        AppendLine($"/// {summary}");
        AppendLine("/// </summary>");
        AppendLine("/// <remarks>");
        AppendLine($"/// {remarks}");
        AppendLine("/// </remarks>");
        return this;
    }

    /// <summary>
    /// Appends a conditional compilation directive.
    /// </summary>
    public CodeBuilder AppendDirective(string directive)
    {
        // Don't indent preprocessor directives
        var savedIndent = _indentLevel;
        _indentLevel = 0;
        _isLineStart = true;

        AppendLine($"#{directive}");

        _indentLevel = savedIndent;
        return this;
    }

    /// <summary>
    /// Appends code within a conditional compilation block.
    /// </summary>
    public CodeBuilder AppendConditional(string condition, Action<CodeBuilder> contentBuilder)
    {
        AppendDirective($"if {condition}");
        contentBuilder(this);
        AppendDirective("endif");
        return this;
    }

    /// <summary>
    /// Creates a scoped indentation block.
    /// </summary>
    public IndentScope BeginScope()
    {
        return new IndentScope(this);
    }

    private void AppendIndent()
    {
        for (int i = 0; i < _indentLevel; i++)
        {
            _builder.Append(IndentString);
        }
    }

    public override string ToString()
    {
        return _builder.ToString();
    }

    /// <summary>
    /// Disposable scope for automatic indentation management.
    /// </summary>
    public readonly struct IndentScope : IDisposable
    {
        private readonly CodeBuilder _builder;

        public IndentScope(CodeBuilder builder)
        {
            _builder = builder;
            _builder.Indent();
        }

        public void Dispose()
        {
            _builder.Unindent();
        }
    }
}

/// <summary>
/// Extension methods for code generation helpers.
/// </summary>
internal static class CodeBuilderExtensions
{
    /// <summary>
    /// Joins a collection with a separator and optional transform.
    /// </summary>
    public static string JoinStrings<T>(this IEnumerable<T> items, string separator, Func<T, string>? selector = null)
    {
        selector ??= item => item?.ToString() ?? string.Empty;
        return string.Join(separator, items.Select(selector));
    }

    /// <summary>
    /// Escapes a string literal for C# code.
    /// </summary>
    public static string ToLiteral(this string value)
    {
        return $"\"{value.Replace("\\", "\\\\").Replace("\"", "\\\"")}\"";
    }

    /// <summary>
    /// Converts a char to a C# char literal.
    /// </summary>
    public static string ToLiteral(this char value)
    {
        return value switch
        {
            '\'' => "'\\''",
            '\\' => "'\\\\'",
            '\0' => "'\\0'",
            '\n' => "'\\n'",
            '\r' => "'\\r'",
            '\t' => "'\\t'",
            _ => $"'{value}'"
        };
    }
}
