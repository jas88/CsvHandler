// Copyright (c) 2024 CsvHandler
// Licensed under the MIT License

using System;
using System.Diagnostics.CodeAnalysis;

namespace CsvHandler;

/// <summary>
/// Base context class for CSV serialization with Native AOT support.
/// Provides metadata and serialization delegates for types registered via source generation.
/// </summary>
/// <remarks>
/// <para>
/// CsvContext serves as the foundation for AOT-compatible CSV serialization by:
/// </para>
/// <list type="bullet">
/// <item>Providing compile-time type metadata through source generation</item>
/// <item>Eliminating reflection-based serialization</item>
/// <item>Enabling full trimming and AOT compilation</item>
/// <item>Offering type-safe serialization through strongly-typed delegates</item>
/// </list>
/// <para>
/// Usage:
/// </para>
/// <code>
/// [CsvSerializable(typeof(Person))]
/// [CsvSerializable(typeof(Order))]
/// public partial class AppCsvContext : CsvContext
/// {
///     // Implementation generated by source generator
/// }
///
/// // Use context with CsvReader/Writer
/// var reader = CsvReader&lt;Person&gt;.Create(stream, AppCsvContext.Default);
/// </code>
/// </remarks>
public abstract class CsvContext
{
    /// <summary>
    /// Gets the default CSV options for this context.
    /// Can be overridden in derived classes to provide custom defaults.
    /// </summary>
    public virtual CsvOptions Options { get; } = CsvOptions.Default;

    /// <summary>
    /// Gets type metadata and serialization delegates for the specified type.
    /// </summary>
    /// <typeparam name="T">The type to get metadata for.</typeparam>
    /// <returns>
    /// A <see cref="CsvTypeInfo{T}"/> instance containing serialization metadata and delegates,
    /// or <c>null</c> if the type is not registered in this context.
    /// </returns>
    /// <remarks>
    /// This method is typically implemented by source generators to provide compile-time
    /// type metadata without reflection. Each registered type returns a pre-configured
    /// CsvTypeInfo instance with serialization delegates.
    /// </remarks>
    public abstract CsvTypeInfo<T>? GetTypeInfo<T>() where T : class;

    /// <summary>
    /// Gets a type handler for CSV serialization/deserialization.
    /// </summary>
    /// <typeparam name="T">The type to get a handler for.</typeparam>
    /// <returns>
    /// An <see cref="ICsvTypeHandler{T}"/> instance for the specified type,
    /// or <c>null</c> if the type is not registered in this context.
    /// </returns>
    public virtual ICsvTypeHandler<T>? GetTypeHandler<T>()
    {
        // Default implementation returns null; source generators override this
        return null;
    }

    /// <summary>
    /// Gets type metadata for CSV writing operations.
    /// </summary>
    /// <typeparam name="T">The type to get metadata for.</typeparam>
    /// <returns>
    /// A <see cref="Core.CsvTypeMetadata{T}"/> instance for the specified type,
    /// or <c>null</c> if the type is not registered in this context.
    /// </returns>
    public virtual Core.CsvTypeMetadata<T>? GetTypeMetadata<T>() where T : class
    {
        // Default implementation returns null; source generators override this
        return null;
    }

    /// <summary>
    /// Gets type metadata for the specified type using non-generic access.
    /// </summary>
    /// <param name="type">The type to get metadata for.</param>
    /// <returns>
    /// A <see cref="CsvTypeInfo"/> instance containing serialization metadata,
    /// or <c>null</c> if the type is not registered in this context.
    /// </returns>
    /// <remarks>
    /// This method provides runtime type access to metadata. It uses the generic
    /// <see cref="GetTypeInfo{T}"/> method internally through reflection-free delegation.
    /// </remarks>
    public virtual CsvTypeInfo? GetTypeInfo(Type type)
    {
        if (type == null)
            throw new ArgumentNullException(nameof(type));

        // This will be overridden by source-generated code to provide
        // efficient type lookup without reflection
        return null;
    }

    /// <summary>
    /// Gets or creates a default context instance.
    /// </summary>
    /// <remarks>
    /// Derived classes should override this to provide a singleton instance:
    /// <code>
    /// private static AppCsvContext? s_default;
    /// public static new AppCsvContext Default => s_default ??= new AppCsvContext();
    /// </code>
    /// </remarks>
    protected static CsvContext? DefaultInstance { get; set; }
}

/// <summary>
/// Default CSV context that uses reflection for types without source generation.
/// </summary>
/// <remarks>
/// This context is provided for backwards compatibility and convenience, but requires
/// reflection and is not compatible with Native AOT. For AOT scenarios, use a source-generated
/// context derived from <see cref="CsvContext"/>.
/// </remarks>
[RequiresUnreferencedCode("DefaultCsvContext uses reflection which is incompatible with trimming and Native AOT. Use a source-generated CsvContext instead.")]
[RequiresDynamicCode("DefaultCsvContext uses reflection which is incompatible with Native AOT. Use a source-generated CsvContext instead.")]
public sealed class DefaultCsvContext : CsvContext
{
    private static DefaultCsvContext? s_default;

    /// <summary>
    /// Gets the default instance of the reflection-based context.
    /// </summary>
    public static DefaultCsvContext Default => s_default ??= new DefaultCsvContext();

    private DefaultCsvContext()
    {
    }

    /// <inheritdoc/>
    public override CsvTypeInfo<T>? GetTypeInfo<T>()
    {
        // Reflection-based fallback - not AOT compatible
        // This would be implemented to use reflection to create CsvTypeInfo at runtime
        // For now, return null to force use of source-generated contexts
        return null;
    }

    /// <inheritdoc/>
    public override CsvTypeInfo? GetTypeInfo(Type type)
    {
        // Reflection-based fallback - not AOT compatible
        return null;
    }
}
